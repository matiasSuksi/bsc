\chapter{Muistinhallinan tekniikoita ja rakenteita} \label{Neljäs luku}

Tässä luvussa tullaan esittelemään yleisiä muistinhallinan tekniikoita, joita voidaan hyödyntää sulautetuissa järjestelmissä.

\section{Rengaspuskuri}

Rengaspuskuri (engl. \textit{circular buffer} on järjestetty tietorakenne, jossa viimeisen alkion jälkeen palataan takaisin ensimmäiseen alkioon. Yleensä rengaspuskuri toteutetaan, joko järjestettynä taulukkona tai linkitettynä listana, jonka viimeinen alkio osoittaa takaisin ensimmäiseen alkioon. Rengaspuskurin etuindeksi (engl. \text{front index}) osoittaa tyhjän paikan, johon seuraavaksi lisättävä alkio laitetaan. Takaindeksi (engl. \text{back index}) osoittaa seuraavaksi poistettavan alkion paikan. Rengaspuskurit ovat erittäin yleisiä tietorakenteita juuri reealiaikaisissa sulautetuissa järjestelmissä, joissa useat prosessit kommunikoivat keskenään. Rengaspuskuri toimii väliaikaisena muistina prosesseille, jolloin prosessit voivat toimia asynkronisesti.\cite{c2015book}

Seuraavaksi esitellään yksinkertaisen kokonaislukuja sisältävän rengaspuskurin totetus.

\begin{algorithm}[tbh]
\begin{lstlisting}[language=C]
typedef struct RengasPuskuri_t {
    int* taulukko;  //Osoitin taulukkoon
    int koko;       //Maksimikoko
    int alkioiden_lukumaara;    //
    int ensimmainen_alkio;  //Indeksi puskurin alkuun
    int viimeinen_alkio;    //Indeksi puskurin loppuun
}
\end{lstlisting}
\caption{Rengaspuskurin implementaatio\label{alg:Rengaspuskuri}}
\end{algorithm}

\section{Segmentoitu pino}

Suurin osa ohjelmista käyttävät aikaisemmassa luvussa esiteltyä pinoa yhtenä muistirakenteena. Tällaista pinoa voidaan tarkemmin nimittää jatkuvaksi pinoksi (engl. \textit{contiguous stack}), sillä tämäntapainen pino varaa yhtenäisen muistialueen ohjelman muistiavaruudesta. Tällaisella perinteisellä jatkuvalla pinolla on kuitenkin heikkouksia sulautetuissa järjestelmissä. Muisti allokoidaan pinolle staattisesti, jolloin pinolla on ennaltamääritetty maksimikoko. Lisäksi jatkuvan pinon ylivuoto (engl. \textit{stackoverflow}) on vaikea havaita, sillä monesti sulautetuissa järjestelmissä käytettävissä matalan tason mikrokontrollereista puuttuu kokonaan muistinsuojausyksikkö (engl. \textit{MPU, memory protection unit}), jolla ylivuoto voitaisiin havaita. Lisäksi muut vaihtoehtoiset menetelmät ylivuodon tunnistamiseen ovat monesti muistinkäytön tehokkuuden kannalta hyvin tehottomia, ja joita monet yleiset sulautetut kääntäjät eivät tue tai tukevat hyvin heikosti. Näistä kääntäjistä esimerkkejä ovat ARM GNU ja LLVM.\cite{bsstes@2023}

Jatkuvan pinon vastapainona on segmentoitu pino (engl. \textit{segmented stack}), joka eroaa jatkuvasta pinosta niin, että pino on jaettu pienempiin erillisiin segmentteihin, jolloin säikeet ja funktiot sekä niiden data allokoidaan omissa segmenteissään.\cite{bsstes@2023}


\section{Buddy Memory Allocation}
\section{Memory Pooling}
\section{Fixed-size Block Allocation}
\section{Memory Banks}
\section{Object Pools}
\section{Slab allocation}