\chapter{Muistinhallinan tekniikoita ja rakenteita} \label{Neljäs luku}

Tässä luvussa tullaan esittelemään yleisiä muistinhallinan tekniikoita, joita voidaan hyödyntää sulautetuissa järjestelmissä.

\section{Rengaspuskuri}

Rengaspuskuri (engl. \textit{circular buffer} on järjestetty tietorakenne, jossa viimeisen alkion jälkeen palataan takaisin ensimmäiseen alkioon. Yleensä rengaspuskuri toteutetaan, joko järjestettynä taulukkona tai linkitettynä listana, jonka viimeinen alkio osoittaa takaisin ensimmäiseen alkioon. Rengaspuskurin etuindeksi (engl. \text{front index}) osoittaa tyhjän paikan, johon seuraavaksi lisättävä alkio laitetaan. Takaindeksi (engl. \text{back index}) osoittaa seuraavaksi poistettavan alkion paikan. Rengaspuskurit ovat erittäin yleisiä tietorakenteita juuri reealiaikaisissa sulautetuissa järjestelmissä, joissa useat prosessit kommunikoivat keskenään. Rengaspuskuri toimii väliaikaisena muistina prosesseille, jolloin prosessit voivat toimia asynkronisesti toistensa suhteen.\cite{c2015book}

Seuraavaksi esitellään yksinkertaisen kokonaislukuja sisältävän rengaspuskurin totetus.

\begin{algorithm}[tbh]
\begin{lstlisting}[language=C]
typedef struct RengasPuskuri_t {
    int* taulukko;  //Osoitin taulukkoon
    int koko;       //Maksimikoko
    int alkioiden_lukumaara;    //
    int ensimmainen_alkio;  //Indeksi puskurin alkuun
    int viimeinen_alkio;    //Indeksi puskurin loppuun
} RengasPuskuri;
\end{lstlisting}
\caption{Rengaspuskurin implementaatio\label{alg:Rengaspuskuri}}
\end{algorithm}

\section{Segmentoitu pino}

Suurin osa ohjelmista käyttävät aikaisemmassa luvussa esiteltyä pinoa yhtenä muistirakenteena. Tällaista pinoa voidaan tarkemmin nimittää jatkuvaksi pinoksi (engl. \textit{contiguous stack}), sillä tämäntapainen pino varaa yhtenäisen muistialueen ohjelman muistiavaruudesta. Tällaisella perinteisellä jatkuvalla pinolla on kuitenkin heikkouksia sulautetuissa järjestelmissä. Muisti allokoidaan pinolle staattisesti eli jo ennen ohjelmakoodin kääntöä, jolloin pinon maksimikoko ajonaikana on ennaltamääritety. Lisäksi jatkuvan pinon ylivuoto (engl. \textit{stackoverflow}) on vaikea havaita, sillä monesti sulautetuissa järjestelmissä käytettävissä matalan tason mikrokontrollereista puuttuu kokonaan muistinsuojausyksikkö (engl. \textit{MPU, memory protection unit}), jolla ylivuoto voitaisiin havaita. Lisäksi muut vaihtoehtoiset menetelmät ylivuodon tunnistamiseen ovat monesti muistinkäytön tehokkuuden kannalta hyvin tehottomia, ja joita monet yleiset sulautetut ohjelmointikielien kääntäjät eivät tue tai tukevat hyvin heikosti. Näistä kääntäjistä esimerkkejä ovat mm. ARM GNU ja LLVM.\cite{bsstes@2023} Tarkennettuna ARM GNU:lla viitataan GNU GCC -kääntäjän optimointiin ARM-prosessoreilla eikä tätä pidä sekoittaa ARM GNU Toolchain:iin, joka on huomattavasti laajempi kokonaisuus kuin pelkkä ohjelmointikielenkääntäjä.(kts. \cite{arm})

Jatkuvan pinon vastapainona on segmentoitu pino (engl. \textit{segmented stack}), joka eroaa jatkuvasta pinosta niin, että pino on jaettu pienempiin erillisiin pienempiin pinoihin (engl. \textit{stacklet}), jolloin säikeet ja funktiot sekä niiden data allokoidaan omissa pinoissaan. Nämä pienemmät pinot allokoidaan dynaamisesti keosta. Segmentoitu pino on harvoin käytetty muistirakenne, koska sillä on tunnetusti huono suorituskyky ja muistinkäyttö on tehotonta. Kuitenkin, monissa mikrokontrolleripohjaisissa järjestelmissä, joita sulautetuissa järjestelmissä paljon käytetään, nämä suorituskykyongelmat häviävät. Lisäksi pinon ylivuototilanteet on helppo selvittää, sillä pääpinon sisällä olevaa pinoa voidaan dynaamisella allokoinnilla kasvattaa tarpeen vaatiessa. Ajonaikainen kirjasto, joka allokoi ja vapauttaa segmentoidun pinon pienempiä pinoja, kohtelee tätä muistirakennetta linkitettynä listana.\cite{bsstes@2023}

Seuraavaksi tullaan perustelemaan miksi segmentoidun pinon aikaisemmin mainitut heikkoudet häviävät.
~\\
\begin{itemize}
    \item{Muistin fragmentoituminen vähenee: Mikrokontrolleripohjaisissa systeemeissä on usein tarpeetonta varata suurta vapaata tilaa segmentoituun pinoon, sillä usein suoritettavien ohjelmatiedostojen vedokset (engl. \textit{image}) linkitetään kokonaan käännön aikana, jolloin dynaamista linkitystä ei tapahdu. Lisäksi, takaisin kutsufunktiot voivat toimia erillisissä segmentoidun pinon pienissä pinoissa, koska käyttöjärjestelmäydin (engl. \textit{kernel}) on tietoinen segmentoidusta pinosta. 
    \item{Koodikannan kontrolli: Hyvin usein kehittäjillä on täysi pääsy koko ohjelman lähdekoodiin, jolloin segmentoitu pino on helppo implementoida koko järjestelmään eikä kehittäjän tarvitse tehdä toteutusta, joka toimisi yhdessä jatkuvan pinon kanssa. Tilanteissa, jossa ulkoinen oheislaitteiden toimittaja tarjoaa binäärikirjastoja laitteilleen, on helppoa tarjoata vain segmentoidulla pinolla käännetty versio. }
    \item{Suorituskyvyn heikentyminen on hyväksyttävämpää: Monesti mikrokontrolleripohjaisissa järjestelmissä hyvä suorituskyky ei synny pelkästään puhtaasta nopeudesta, vaan järjestelmän tilan ennustettavuudesta. Lisäksi nopeuden menetyksestä syntävät energiakustannukset voidaan kompensoida käyttämällä pienempää muistia.}
\end{itemize}\cite{bsstes@2023}
~\\
Segmentoitu pino tuo esiin uusia mahdollisuuksia ja hyötyjä sulautetuissa järjestelmissä.
\begin{itemize}
    \item{Muistinkäytön turvallisuus voidaan saavuttaa ohjelmointikielen kääntäjällä: Monesti sulautettujen järjestelmien mikrokontrollerit eivät sisällä muistinhallintayksikköä tai edes muistinsuojausyksikköä. Tällöin järjestelmän muistiosoitteavaruutta ei ole virtualisoitu, vaan järjestelmän tehtävät käyttävät fyysisiä muistiosoitteita eikä pinon ylivuodolle ole automaattista suojautumista. On suuri riski, että yhden pinon ylivuoto helposti korruptoi huomaamatta toisen pinon dataa toisessa tehtävässä. Muistiturvallisuus voidaan tässä tilanteessa pyrkiä saavuttamaan kääntäjän tarjoamilla pinon testauskäskyillä. Ennen funktioiden ajoa, nämä testauskäskyt testaavat pinokehyksien välisiä muistiosoitteita kirjoittamalla niihin tasaisten intervallien välein. Tämä menetelmä on tehokas segmentoidussa pinossa, kun pinokehykset ovat tarpeeksi isoja.
    \item{Laitteisto- ja energiatehokkuus: Segmentoitu pino mahdollistaa staattisen RAM-muistin (lyh. \textit{SRAM}) vähentämisen järjestelmässä, koska staattista RAM-muistia voidaan jakaa pinojen välillä väliaikaisesti. Staattisen RAM-muistin vähentämisellä on kaksi etua. Järjestelmän laitteiston valmistaminen on halvempaa, koska muistia on vähemmän, ja koska muistia on vähemmän niin järjestelmän virrankulutus pienenee. Myös, aikaisemmin mainittu usein jatkuvan pinon varaama tyhjä käyttämätön tila kuluttaa turhaa energiaa.
\end{itemize}\cite{bsstes@2023}

~\\

\section{Buddy-algoritmi}

Buddy-algoritmi (engl. \textit{buddy algorithm}, myös \textit{buddy memory allocation}) on muistinhallintatekniikka, joka yhdistää ja jakaa muistilohkoja tarpeen vaatiessa. Jos jokin tehtävä vaatii suurta muistilohkoa, buddy-algoritmi yhdistää lohkot, joilla on peräkkäiset muistiosoitteet. Vastapuolisesti se jakaa suuren lohkon, ja antaa siitä osan tehtävällä joka pyytää käyttöönsä lisää muistia. Alkuperäisessä buddy-algoritmissa on ongelmana se, että kun yksi tehtävä vapauttaa lohkon, algoritmi pyrkii yhdistämään lohkon välittömästi muiden lohkojen kanssa. Kun yhdistäminen on tapahtunut ja jokin tehtävä pyytää uudelleen samaa lohkokokoa eikä sen kokoista lohkoa ole vapaana saatavilla, buddy-algoritmi joutuu jakamaan saman lohkon uudelleen. Kun tätä edestakaisin tapahtuvaa jakamista ja yhdistämistä tapahtuu usein, järjestelmän suorituskyky alkaa heikentymään, joka on hyvin huono asia sulautetussa järjestelmässä. Kuitenkin, buddy-algorimistä on useita versioita ja yksi näistä onkin hyvin käyttökelpoinen sulautetussa järjestelmässä. Tämä on niin sanottu laiska buddy-algoritmi. Laiska buddy-algoritmi (engl. \textit{lazy buddy algorithm}) on buddy-algroitmi, joka viivästyttää yhdistämisen ajankohtaa, kun tehtävä on vapauttanut lohkon. Yhdistämisprosessi tapahtuu ainoastaan silloin, kun se on aivan välttämätöntä. Tämä parantaa suorituskykyä, sillä nyt tätä edestakaisin tapahtuvaa yhdistämistä ja jakamista tapahtuu huomattavasti vähemmän.\cite{soeosmm@2009}

