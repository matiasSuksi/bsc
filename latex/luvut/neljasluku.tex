\chapter{Muistinhallinan tekniikoita ja rakenteita} \label{Neljäs luku}

Tässä luvussa tullaan esittelemään yleisiä muistinhallinan tekniikoita, joita voidaan hyödyntää sulautetuissa järjestelmissä.

\section{Rengaspuskuri}

Rengaspuskuri (engl. \textit{circular buffer} on järjestetty tietorakenne, jossa viimeisen alkion jälkeen palataan takaisin ensimmäiseen alkioon. Yleensä rengaspuskuri toteutetaan, joko järjestettynä taulukkona tai linkitettynä listana, jonka viimeinen alkio osoittaa takaisin ensimmäiseen alkioon. Rengaspuskurin etuindeksi (engl. \text{front index}) osoittaa tyhjän paikan, johon seuraavaksi lisättävä alkio laitetaan. Takaindeksi (engl. \text{back index}) osoittaa seuraavaksi poistettavan alkion paikan. Rengaspuskurit ovat erittäin yleisiä tietorakenteita juuri reealiaikaisissa sulautetuissa järjestelmissä, joissa useat prosessit kommunikoivat keskenään. Rengaspuskuri toimii väliaikaisena muistina prosesseille, jolloin prosessit voivat toimia asynkronisesti.\cite{c2015book}

Seuraavaksi esitellään yksinkertaisen kokonaislukuja sisältävän rengaspuskurin totetus.

\begin{algorithm}[tbh]
\begin{lstlisting}[language=C]
typedef struct RengasPuskuri_t {
    int* taulukko;  //Osoitin taulukkoon
    int koko;       //Maksimikoko
    int alkioiden_lukumaara;    //
    int ensimmainen_alkio;  //Indeksi puskurin alkuun
    int viimeinen_alkio;    //Indeksi puskurin loppuun
}
\end{lstlisting}
\caption{Rengaspuskurin implementaatio\label{alg:Rengaspuskuri}}
\end{algorithm}

\section{Segmentoitu pino}

Suurin osa ohjelmista käyttävät aikaisemmassa luvussa esiteltyä pinoa yhtenä muistirakenteena. Tällaista pinoa voidaan tarkemmin nimittää jatkuvaksi pinoksi (engl. \textit{contiguous stack}), sillä tämäntapainen pino varaa yhtenäisen muistialueen ohjelman muistiavaruudesta. Tällaisella perinteisellä jatkuvalla pinolla on kuitenkin heikkouksia sulautetuissa järjestelmissä. Muisti allokoidaan pinolle staattisesti eli jo ennen ohjelmakoodin kääntöä, jolloin pinon maksimikoko ajonaikana on ennaltamääritety. Lisäksi jatkuvan pinon ylivuoto (engl. \textit{stackoverflow}) on vaikea havaita, sillä monesti sulautetuissa järjestelmissä käytettävissä matalan tason mikrokontrollereista puuttuu kokonaan muistinsuojausyksikkö (engl. \textit{MPU, memory protection unit}), jolla ylivuoto voitaisiin havaita. Lisäksi muut vaihtoehtoiset menetelmät ylivuodon tunnistamiseen ovat monesti muistinkäytön tehokkuuden kannalta hyvin tehottomia, ja joita monet yleiset sulautetut ohjelmointikielien kääntäjät eivät tue tai tukevat hyvin heikosti. Näistä kääntäjistä esimerkkejä ovat ARM GNU ja LLVM.\cite{bsstes@2023}

Jatkuvan pinon vastapainona on segmentoitu pino (engl. \textit{segmented stack}), joka eroaa jatkuvasta pinosta niin, että pino on jaettu pienempiin erillisiin pienempiin pinoihin (engl. \textit{stacklet}), jolloin säikeet ja funktiot sekä niiden data allokoidaan omissa pinoissaan. Nämä pienemmät pinot allokoidaan dynaamisesti keosta. Segmentoitu pino on harvoin käytetty muistirakenne, koska sillä on tunnetusti huono suorituskyky ja muistinkäyttö on tehotonta. Kuitenkin, monissa mikrokontrolleripohjaisissa järjestelmissä, joita sulautetuissa järjestelmissä paljon käytetään, nämä suorituskykyongelmat häviävät. Lisäksi pinon ylivuototilanteet on helppo selvittää, sillä pääpinon sisällä olevaa pinoa voidaan dynaamisella allokoinnilla kasvattaa tarpeen vaatiessa. Ajon aikainen kirjasto, joka allokoi ja vapauttaa segmentoidun pinon pienempiä pinoja, kohtelee tätä muistirakennetta linkitettynä listana.\cite{bsstes@2023}

Segmentoitu pinon hyöty sulatetuissa järjestelmissä on aikaisemmin mainittujen haittojen häviäminen ja uusien muistin optimointimahdollisuuksien syntyminen.

Heikkoudet häviävät:
\begin{itemize}
    \item{Muistin fragmentoituminen vähenee: Mikrokontrolleripohjaisissa systeemeissä on usein tarpeetonta varata suurta vapaata tilaa segmentoituun pinoon.}
    \item{Koodikannan kontrollin paranemimen:  }
    \item{Suorituskyvyn heikentyminen on hyväksyttävämpää: }
\end{itemize}

Uusia mahdollisuuksia syntyy:
\begin{itemize}
    \item{Muistinkäytön turvallisuus voidaan saavuttaa ohjelmointikielen kääntäjällä: }
    \item{Laitteisto- ja energiatehokkuus: }
\end{itemize}

\section{Buddy Memory Allocation}
\section{Memory Pooling}
\section{Fixed-size Block Allocation}
\section{Memory Banks}
\section{Object Pools}
\section{Slab allocation}